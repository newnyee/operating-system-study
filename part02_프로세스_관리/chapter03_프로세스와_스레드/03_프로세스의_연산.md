## 03. 프로세스의 연산
### 프로세스의 구조
|   영역    |                                                      설명                                                      |
|:-------:|:------------------------------------------------------------------------------------------------------------:|
|  코드 영역  |                                         프로세스의 본문 기술<br/>***읽기 전용***                                          |
| 데이터 영역  |                                    코드가 실행되면서 사용되는 각종 데이터<br/>***읽기, 쓰기***                                    |
|  스택 영역  | 운영체제가 사용자의 프로세스를 작동하기 위해 유지하는 영역<br/>예) 프로세스 내에서 함수를 호출하면 함수를 수행하고 원래 프로그램으로 되돌아올 위치를 스택에 저장<br/>***숨김 영역*** |

### 프로세스의 생성과 복사
- 프로그램 실행 → 운영체제가 해당 프로그램을 메모리로 가져옴 → 코드 영역에 넣고 프로세스 제어 블록을 생성
- 프로세스 생성방법 : 새로 생성, 실행 중인 프로세스에서 새로운 프로세스를 복사

#### fork() 시스템 호출의 개념
- 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수
- 커널에서 제공함
- fork() 시스템 호출을 이용하면 새로 프로세스를 생성하는 속도보다 빠름
- fork() 시스템 호출로 생성된 프로세스는 부모-자식(실행하던 프로세스-복사된 프로세스) 관계를 형성

#### fork() 시스템 호출의 동작 과정
| 구분자                |  부모 프로세스   |  자식 프로세스  | 설명                                                                              |
|--------------------|:----------:|:---------:|:--------------------------------------------------------------------------------|
| PID (프로세스 구분자)     |    326     |    328    | - 고유 아이디이므로 자식 프로세스의 아이디 새로 생성됨                                                 |
| PPID (부모 프로세스 구분자) |    123     |    326    | - 부모 프로세스의 PID로 자식프로세스의 PPID가 설정됨                                               |
| CPID (자식 프로세스 구분자) |  -1 → 368  |    -1     | - 부모 프로세스의 CPID가 자식 프로세스의 PID로 설정됨<br/> - 자식 프로세스의경우 해당하는 자식 프로세스가 없으므로 -1로 설정됨 |
*모든 프로세스는 부모 프로세스를 가지고 있어야 함 → 프로세스는 PPID를 무조건 가지고있음

#### fork() 시스템 호출의 장점
- 프로세스의 생성 속도가 빠름
  <br> 하드디스크로부터 프로그램을 새로 가져오지 않고 기존 메모리에서 복사하기 때문에 자식 프로세스의 생성속도가 빠름
- 추가 작업 없이 자원을 상속할 수 있음
  <br> 부모 프로세서가 사용하던 모든 자원을 추가 작업 없이 자식 프로세스에 상속할 수 있음
- 시스템 관리를 효율적으로 할 수 있음
  <br> 부모 프로세스와 자식 프로세스가 구분자로 연결되어 있기 때문에, 자식 프로세스를 종료하면 자식이 사용하더 자원을 부모 프로세스가 정리할 수 있음

#### fork() 시스템 호출의 예
```c
#include <stdio.h>
#include <unistd.h>

void main()
{  int pid;
   pid = fork();
   if(pid < 0) { printf("Error");
                 exit(-1); }
   else if(pid == 0) { printf("Child"); // 자식 프로세스
                       exit(0); }
   else { printf("Parent"); // 부모 프로세스
          exit(0); }
```

### 프로세스의 전환
#### exec() 시스템 호출의 개념
- 프로세스는 그대로 둔 채 내용만 바꾸는 시스템 호출
- exec() 시스템 호출의 목적
    - 프로세스의 구조를 재활용 하기 위한 목적
    - 새로운 코드 영역만 가져오고, 이미 만들어진 프로세스 제어 블록, 메모리 영역, 부모-자식 관계를 그대로 사용할 수 있음

#### exec() 시스템 호출의 동작 과정
- 코드 영역 : 기존 내용이 지워지고 새로운 코드로 바뀜
- 데이터 영역 : 새로운 변수로 채워짐
- 스택 영역 : 리셋됨
- 프로그램 카운터 레지스터 값을 비롯한 각종 레지스터와 사용한 파일 정보가 모두 리셋됨
- PCB의 내용 중 PID, PPID, CPID, 메모리 관련 사항 등은 변하지 않음

#### exec() 시스템 호출의 예
```c
#include <stdio.h>
#include <unistd.h>

void main()
{  int pid;
   pid = fork();
   if(pid < 0) { printf("Error");
                 exit(-1); }
   else if(pid == 0) { // 자식 프로세스
                       execlp("mplayer", "mplayer", NULL); // 내용을 바꾸는 로직 
                       exit(0); }
   else { // 부모 프로세스
          wait(NULL); // 자식 프로세스가 끝날때까지 기다림
          printf("mplayer Terminated");
          exit(0); }
```

### 프로세스의 계층 구조
#### 유닉스의 프로세스 계층 구조
- init 프로세스
    - 유닉스에서 커널이 처음 메모리에 올라와 부팅되면 커널 관련 프로세스를 여러개 만드는데, init 프로세스가 그 중 하나
    - 전체 프로세스의 출발점
    - 운영체제에 있는 모든 프로세스의 부모 프로세스 (자바의 Object Class의 개념)
- init 프로세스는 fork()와 exec() 시스템 호출을 이용하여 자식 프로세스를 만듦
- init 프로세스의 자식으로는 login 프로세스, shell 프로세스 등이 있음

#### 프로세스 계층 구조의 장점
- 여러 작업 동시 처리
    - login 프로세스 : 유닉스 운영체제는 여러 사용자를 동시에 처리하기 위해 fork() 시스템 호출로 login 프로세스를 여러 개 만들어 사용자에게 나누어줌
    - shell 프로세스 : exec() 시스템 호출을 사용하여 login 프로세스를 shell 프로세스로 바꾼 뒤 사용자의 명령을 기다림
    - 그 결과 login 프로세스와 shell 프로세스에 부모-자식 관계가 성립됨
- 용이한 자원 회수
    - 모든 프로세스가 독립적으로 만들어지면 프로세스가 종료될 때마다 운영체제가 직접 자원을 회수해야하므로 작업이 복잡해짐
    - 모든 프로세스를 부모-자식 관계로 만들면 자식 프로세스가 작업을 마쳤을 때 사용하던 자원을 부모 프로세스가 회수할 수 있음

#### 고아 프로세스와 좀비 프로세스
- 고아 프로세스 : 부모 프로세스가 먼저 종료되어 돌아갈 곳이 없는 프로세스
- 좀비 프로세스 : 자식 프로세스가 종료되었으나 부모 프로세스가 자원 회수를 하지 않는 경우
- main() 함수의 맨 마지막에 exit() 또는 return() 문을 사용하여 프로세스의 작업 종료를 알려야함